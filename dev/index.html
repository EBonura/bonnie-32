<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[DEV] BONNIE-32 v0.1.10</title>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a2e;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            outline: none;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #eee;
            font-family: monospace;
            font-size: 18px;
            z-index: 10;
            text-align: center;
        }
        #loading-bar-container {
            width: 300px;
            height: 8px;
            background: #333;
            border-radius: 4px;
            margin-top: 16px;
            overflow: hidden;
        }
        #loading-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00bfe6, #00d4ff);
            border-radius: 4px;
            transition: width 0.1s ease-out;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading BONNIE-32 (DEV) v0.1.10...</div>
        <div id="loading-bar-container">
            <div id="loading-bar"></div>
        </div>
        <div id="loading-status" style="margin-top: 8px; font-size: 14px; color: #888;"></div>
    </div>
    <canvas id="glcanvas" tabindex="1"></canvas>
    <script src="mq_js_bundle.js"></script>
    <!-- DISABLED FOR TESTING: <script src="https://fornwall.github.io/gamepads/js/macroquad-gamepads-0.1.js"></script> -->
    <script>
    (function() {
        'use strict';

        // Disable context menu on canvas
        document.getElementById('glcanvas').addEventListener('contextmenu', function(e) {
            e.preventDefault();
        });

        // =============================================================================
        // WASM Memory Helpers
        // =============================================================================

        function readWasmString(ptr, len) {
            return new TextDecoder().decode(
                new Uint8Array(wasm_exports.memory.buffer, ptr, len)
            );
        }

        function writeWasmBytes(ptr, data, maxLen) {
            var len = Math.min(data.length, maxLen);
            new Uint8Array(wasm_exports.memory.buffer, ptr, len).set(
                data.subarray ? data.subarray(0, len) : data.slice(0, len)
            );
            return len;
        }

        // =============================================================================
        // File Import/Export (Level files via localStorage)
        // =============================================================================

        var FileIO = {
            import: function() {
                var input = document.createElement('input');
                input.type = 'file';
                input.accept = '.ron';
                input.onchange = function(e) {
                    var file = e.target.files[0];
                    if (file) {
                        var reader = new FileReader();
                        reader.onload = function(e) {
                            // Security: Sanitize filename - remove path components, limit length
                            var safeName = file.name.replace(/^.*[\\\/]/, '').substring(0, 255);
                            // Ensure it ends with .ron
                            if (!safeName.toLowerCase().endsWith('.ron')) {
                                safeName = 'level.ron';
                            }
                            localStorage.setItem('_b32_import_data', e.target.result);
                            localStorage.setItem('_b32_import_filename', safeName);
                            localStorage.setItem('_b32_import_ready', 'true');
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            },

            checkImport: function() {
                return localStorage.getItem('_b32_import_ready') === 'true' ? 1 : 0;
            },

            getImportDataLen: function() {
                return (localStorage.getItem('_b32_import_data') || '').length;
            },

            getImportFilenameLen: function() {
                return (localStorage.getItem('_b32_import_filename') || '').length;
            },

            copyImportData: function(ptr, maxLen) {
                var data = localStorage.getItem('_b32_import_data') || '';
                return writeWasmBytes(ptr, new TextEncoder().encode(data), maxLen);
            },

            copyImportFilename: function(ptr, maxLen) {
                var filename = localStorage.getItem('_b32_import_filename') || '';
                return writeWasmBytes(ptr, new TextEncoder().encode(filename), maxLen);
            },

            clearImport: function() {
                localStorage.removeItem('_b32_import_ready');
                localStorage.removeItem('_b32_import_data');
                localStorage.removeItem('_b32_import_filename');
            },

            setExportData: function(ptr, len) {
                localStorage.setItem('_b32_export_data', readWasmString(ptr, len));
            },

            setExportFilename: function(ptr, len) {
                localStorage.setItem('_b32_export_filename', readWasmString(ptr, len));
            },

            triggerDownload: function() {
                var data = localStorage.getItem('_b32_export_data');
                var filename = localStorage.getItem('_b32_export_filename') || 'level.ron';
                if (data) {
                    var a = document.createElement('a');
                    a.href = URL.createObjectURL(new Blob([data], { type: 'text/plain' }));
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    localStorage.removeItem('_b32_export_data');
                    localStorage.removeItem('_b32_export_filename');
                }
            }
        };

        // =============================================================================
        // Loading UI
        // =============================================================================

        var LoadingUI = {
            setProgress: function(current, total) {
                var bar = document.getElementById('loading-bar');
                if (bar) bar.style.width = (total > 0 ? (current / total) * 100 : 0) + '%';
            },

            setStatus: function(ptr, len) {
                var el = document.getElementById('loading-status');
                if (el) el.textContent = readWasmString(ptr, len);
            },

            hide: function() {
                var el = document.getElementById('loading');
                if (el) el.style.display = 'none';
            }
        };

        // =============================================================================
        // Audio Output (Web Audio API for synthesizer playback)
        // =============================================================================

        var AudioOutput = {
            ctx: null,
            sampleRate: 44100,
            workletNode: null,
            workletReady: false,

            init: function(sampleRate) {
                AudioOutput.sampleRate = sampleRate;
                console.log('Audio output initialized, sample rate:', sampleRate);
            },

            ensureContext: async function() {
                if (!AudioOutput.ctx) {
                    try {
                        AudioOutput.ctx = new (window.AudioContext || window.webkitAudioContext)({
                            sampleRate: AudioOutput.sampleRate
                        });
                        console.log('AudioContext created, state:', AudioOutput.ctx.state);

                        // Load and register the AudioWorklet processor
                        await AudioOutput.ctx.audioWorklet.addModule('audio-processor.js');
                        console.log('AudioWorklet module loaded');

                        // Create the worklet node
                        AudioOutput.workletNode = new AudioWorkletNode(AudioOutput.ctx, 'b32-audio-processor', {
                            outputChannelCount: [2]
                        });
                        AudioOutput.workletNode.connect(AudioOutput.ctx.destination);
                        AudioOutput.workletReady = true;
                        console.log('AudioWorklet node connected');
                    } catch (e) {
                        console.error('Failed to create AudioContext or Worklet:', e);
                        return null;
                    }
                }
                if (AudioOutput.ctx.state === 'suspended') {
                    AudioOutput.ctx.resume();
                }
                return AudioOutput.ctx;
            },

            write: function(leftPtr, rightPtr, len) {
                // Ensure context is initialized (async, but we call it synchronously)
                if (!AudioOutput.ctx) {
                    AudioOutput.ensureContext();
                    return; // Skip this frame while initializing
                }

                if (!AudioOutput.workletReady || !AudioOutput.workletNode) {
                    return; // Worklet not ready yet
                }

                // Resume if suspended (user interaction required)
                if (AudioOutput.ctx.state === 'suspended') {
                    AudioOutput.ctx.resume();
                }

                // Copy samples from WASM memory
                var leftView = new Float32Array(wasm_exports.memory.buffer, leftPtr, len);
                var rightView = new Float32Array(wasm_exports.memory.buffer, rightPtr, len);

                // Copy to new arrays (can't transfer views of WASM memory)
                var leftCopy = new Float32Array(len);
                var rightCopy = new Float32Array(len);
                leftCopy.set(leftView);
                rightCopy.set(rightView);

                // Send to worklet via message port
                AudioOutput.workletNode.port.postMessage({
                    type: 'audio',
                    left: leftCopy,
                    right: rightCopy
                });
            }
        };

        // =============================================================================
        // Asset Loading Progress (shared across textures and soundfont)
        // =============================================================================

        var AssetLoader = {
            total: 0,
            loaded: 0,

            reset: function() {
                AssetLoader.total = 0;
                AssetLoader.loaded = 0;
            },

            addTotal: function(count) {
                AssetLoader.total += count;
            },

            increment: function() {
                AssetLoader.loaded++;
                AssetLoader.updateBar();
            },

            updateBar: function() {
                var barEl = document.getElementById('loading-bar');
                if (barEl && AssetLoader.total > 0) {
                    barEl.style.width = (AssetLoader.loaded / AssetLoader.total * 100) + '%';
                }
            },

            setStatus: function(msg) {
                var statusEl = document.getElementById('loading-status');
                if (statusEl) statusEl.textContent = msg;
            }
        };

        // =============================================================================
        // Soundfont Cache (fetch raw bytes for SF2 playback)
        // =============================================================================

        var SoundfontCache = {
            data: null,
            loaded: false,
            path: 'assets/runtime/soundfonts/TimGM6mb.sf2',

            isLoaded: function() {
                return SoundfontCache.loaded ? 1 : 0;
            },

            getSize: function() {
                return SoundfontCache.data ? SoundfontCache.data.length : 0;
            },

            copyData: function(destPtr, maxLen) {
                if (!SoundfontCache.data) return 0;
                return writeWasmBytes(destPtr, SoundfontCache.data, maxLen);
            },

            prefetch: async function() {
                AssetLoader.addTotal(1); // Count soundfont as 1 asset
                try {
                    var response = await fetch(SoundfontCache.path);
                    if (!response.ok) {
                        console.warn('Soundfont not found:', SoundfontCache.path);
                        AssetLoader.increment();
                        return;
                    }
                    var buffer = await response.arrayBuffer();
                    SoundfontCache.data = new Uint8Array(buffer);
                    SoundfontCache.loaded = true;
                    AssetLoader.increment();
                    console.log('Soundfont loaded:', SoundfontCache.data.length, 'bytes');
                } catch (err) {
                    console.warn('Failed to load soundfont:', err);
                    AssetLoader.increment();
                }
            }
        };

        // =============================================================================
        // Texture Cache (parallel prefetch + native PNG decoding)
        // =============================================================================

        var TextureCache = {
            cache: {},
            complete: false,
            total: 0,
            loaded: 0,
            timings: {
                startTime: 0,
                fetchTime: 0,
                decodeTime: 0,
                totalBytes: 0
            },

            isComplete: function() {
                return TextureCache.complete ? 1 : 0;
            },

            getInfo: function(ptr, pathLen) {
                var tex = TextureCache.cache[readWasmString(ptr, pathLen)];
                return tex ? (tex.width << 16) | tex.height : 0;
            },

            copyData: function(pathPtr, pathLen, destPtr, maxLen) {
                var tex = TextureCache.cache[readWasmString(pathPtr, pathLen)];
                if (!tex || !tex.data) return 0;
                return writeWasmBytes(destPtr, tex.data, maxLen);
            },

            decodePng: function(blob) {
                return new Promise(function(resolve, reject) {
                    var img = new Image();
                    var url = URL.createObjectURL(blob);
                    img.onload = function() {
                        var canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        var ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        resolve({
                            width: img.width,
                            height: img.height,
                            data: ctx.getImageData(0, 0, img.width, img.height).data
                        });
                        URL.revokeObjectURL(url);
                    };
                    img.onerror = function() {
                        URL.revokeObjectURL(url);
                        reject(new Error('Failed to decode image'));
                    };
                    img.src = url;
                });
            },

            prefetchAll: async function() {
                AssetLoader.setStatus('Loading manifest...');
                TextureCache.timings.startTime = performance.now();

                try {
                    // Load top-level manifest (list of pack names)
                    var packsManifest = await (await fetch('assets/samples/texture-packs/manifest.txt')).text();
                    var packNames = packsManifest.split('\n').map(function(s) { return s.trim(); }).filter(Boolean);

                    // Load each pack's manifest and collect all paths
                    var paths = [];
                    for (var i = 0; i < packNames.length; i++) {
                        var packName = packNames[i];
                        try {
                            var packManifest = await (await fetch('assets/samples/texture-packs/' + packName + '/manifest.txt')).text();
                            packManifest.split('\n').forEach(function(line) {
                                line = line.trim();
                                if (line) {
                                    paths.push('assets/samples/texture-packs/' + packName + '/' + line);
                                }
                            });
                        } catch (e) {
                            console.warn('Failed to load manifest for pack:', packName);
                        }
                    }

                    TextureCache.total = paths.length;
                    AssetLoader.addTotal(paths.length);
                    AssetLoader.setStatus('Loading assets...');

                    var fetchStart = performance.now();

                    // Fetch and decode all in parallel
                    await Promise.all(paths.map(function(path) {
                        var fetchEnd, blobSize;
                        return fetch(path)
                            .then(function(r) {
                                return r.blob();
                            })
                            .then(function(blob) {
                                blobSize = blob.size;
                                TextureCache.timings.totalBytes += blobSize;
                                fetchEnd = performance.now();
                                return TextureCache.decodePng(blob);
                            })
                            .then(function(decoded) {
                                TextureCache.cache[path] = decoded;
                                TextureCache.loaded++;
                                AssetLoader.increment();
                            })
                            .catch(function(err) {
                                console.warn('Failed to load texture:', path, err);
                                TextureCache.loaded++;
                                AssetLoader.increment();
                            });
                    }));

                    var totalTime = performance.now() - TextureCache.timings.startTime;
                    var fetchTime = performance.now() - fetchStart;

                    // Log timing summary
                    console.log('=== Texture Loading Performance ===');
                    console.log('Total textures:', TextureCache.total);
                    console.log('Total PNG bytes:', (TextureCache.timings.totalBytes / 1024 / 1024).toFixed(2), 'MB');
                    console.log('Total load time:', totalTime.toFixed(0), 'ms');
                    console.log('Throughput:', (TextureCache.timings.totalBytes / 1024 / totalTime).toFixed(2), 'KB/ms');
                    console.log('Avg per texture:', (totalTime / TextureCache.total).toFixed(2), 'ms');
                    console.log('===================================');

                    TextureCache.complete = true;
                    AssetLoader.setStatus('Starting engine...');

                } catch (err) {
                    console.error('Prefetch failed:', err);
                    TextureCache.complete = true;
                }
            }
        };

        // =============================================================================
        // Gamepad Input (Web Gamepad API)
        // =============================================================================

        var GamepadInput = {
            // Standard gamepad button mapping (same order as gilrs/gamepads crate)
            // Index: Button name (Xbox layout)
            // 0: A (ActionDown)
            // 1: B (ActionRight)
            // 2: X (ActionLeft)
            // 3: Y (ActionUp)
            // 4: LB (FrontLeftUpper)
            // 5: RB (FrontRightUpper)
            // 6: LT (FrontLeftLower)
            // 7: RT (FrontRightLower)
            // 8: Back/Select
            // 9: Start
            // 10: L3 (LeftStick click)
            // 11: R3 (RightStick click)
            // 12: DPad Up
            // 13: DPad Down
            // 14: DPad Left
            // 15: DPad Right
            // 16: Guide (Xbox button)

            lastButtonStates: new Array(17).fill(false),

            hasGamepad: function() {
                var gamepads = navigator.getGamepads();
                for (var i = 0; i < gamepads.length; i++) {
                    if (gamepads[i] && gamepads[i].connected) return 1;
                }
                return 0;
            },

            // Get first connected gamepad
            getGamepad: function() {
                var gamepads = navigator.getGamepads();
                for (var i = 0; i < gamepads.length; i++) {
                    if (gamepads[i] && gamepads[i].connected) return gamepads[i];
                }
                return null;
            },

            // Get button state as bitmask (buttons 0-16)
            getButtonMask: function() {
                var gp = GamepadInput.getGamepad();
                if (!gp) return 0;
                var mask = 0;
                for (var i = 0; i < Math.min(gp.buttons.length, 17); i++) {
                    if (gp.buttons[i].pressed) {
                        mask |= (1 << i);
                    }
                }
                return mask;
            },

            // Get "just pressed" buttons as bitmask (rising edge detection)
            getButtonPressedMask: function() {
                var gp = GamepadInput.getGamepad();
                if (!gp) {
                    // Reset last states if no gamepad
                    GamepadInput.lastButtonStates.fill(false);
                    return 0;
                }

                var mask = 0;
                for (var i = 0; i < Math.min(gp.buttons.length, 17); i++) {
                    var nowPressed = gp.buttons[i].pressed;
                    var wasPressed = GamepadInput.lastButtonStates[i];
                    if (nowPressed && !wasPressed) {
                        mask |= (1 << i);
                    }
                    GamepadInput.lastButtonStates[i] = nowPressed;
                }
                return mask;
            },

            // Get left stick X axis (-1.0 to 1.0) as i32 fixed point (*10000)
            getLeftStickX: function() {
                var gp = GamepadInput.getGamepad();
                if (!gp || gp.axes.length < 1) return 0;
                return Math.round(gp.axes[0] * 10000);
            },

            getLeftStickY: function() {
                var gp = GamepadInput.getGamepad();
                if (!gp || gp.axes.length < 2) return 0;
                return Math.round(gp.axes[1] * 10000);
            },

            getRightStickX: function() {
                var gp = GamepadInput.getGamepad();
                if (!gp || gp.axes.length < 3) return 0;
                return Math.round(gp.axes[2] * 10000);
            },

            getRightStickY: function() {
                var gp = GamepadInput.getGamepad();
                if (!gp || gp.axes.length < 4) return 0;
                return Math.round(gp.axes[3] * 10000);
            },

            // Get trigger values (0.0 to 1.0) as i32 fixed point (*10000)
            getLeftTrigger: function() {
                var gp = GamepadInput.getGamepad();
                if (!gp || gp.buttons.length < 7) return 0;
                return Math.round(gp.buttons[6].value * 10000);
            },

            getRightTrigger: function() {
                var gp = GamepadInput.getGamepad();
                if (!gp || gp.buttons.length < 8) return 0;
                return Math.round(gp.buttons[7].value * 10000);
            },

            // Copy gamepad name to WASM memory, returns length
            copyName: function(destPtr, maxLen) {
                var gp = GamepadInput.getGamepad();
                if (!gp) return 0;
                var name = gp.id || "";
                var encoder = new TextEncoder();
                var bytes = encoder.encode(name);
                var len = Math.min(bytes.length, maxLen);
                var mem = new Uint8Array(wasm_memory.buffer, destPtr, len);
                mem.set(bytes.subarray(0, len));
                return len;
            }
        };

        // Listen for gamepad connections (for debugging)
        window.addEventListener('gamepadconnected', function(e) {
            console.log('Gamepad connected:', e.gamepad.id);
        });
        window.addEventListener('gamepaddisconnected', function(e) {
            console.log('Gamepad disconnected:', e.gamepad.id);
        });

        // =============================================================================
        // MIDI Input (Web MIDI API)
        // =============================================================================

        var MidiInput = {
            access: null,
            input: null,
            deviceName: "",
            // Ring buffer for messages (max 256 messages between polls)
            // Each message: [type, note, velocity] where type: 0=off, 1=on, 2=cc
            messages: new Uint8Array(256 * 3),
            messageCount: 0,

            // Request MIDI access (async, called on first poll)
            requestAccess: async function() {
                if (MidiInput.access) return true;

                try {
                    MidiInput.access = await navigator.requestMIDIAccess();
                    console.log('Web MIDI access granted');

                    // Auto-connect to first input
                    MidiInput.access.inputs.forEach(function(input) {
                        if (!MidiInput.input) {
                            MidiInput.connectInput(input);
                        }
                    });

                    // Listen for device changes
                    MidiInput.access.onstatechange = function(e) {
                        if (e.port.type === 'input' && e.port.state === 'connected' && !MidiInput.input) {
                            MidiInput.connectInput(e.port);
                        }
                    };

                    return true;
                } catch (e) {
                    console.warn('Web MIDI not available:', e);
                    return false;
                }
            },

            connectInput: function(input) {
                if (MidiInput.input) {
                    MidiInput.input.onmidimessage = null;
                }
                MidiInput.input = input;
                MidiInput.deviceName = input.name || "MIDI Device";
                input.onmidimessage = MidiInput.onMessage;
                console.log('MIDI connected:', MidiInput.deviceName);
            },

            onMessage: function(event) {
                var data = event.data;
                if (data.length < 2) return;

                var status = data[0] & 0xF0;
                var note = data[1];
                var velocity = data.length > 2 ? data[2] : 0;

                // Convert to simple format: type (0=off, 1=on, 2=cc), note, velocity
                var msgType;
                if (status === 0x90 && velocity > 0) {
                    msgType = 1; // Note on
                } else if (status === 0x80 || (status === 0x90 && velocity === 0)) {
                    msgType = 0; // Note off
                } else if (status === 0xB0) {
                    msgType = 2; // CC
                } else {
                    return; // Ignore other messages
                }

                // Add to ring buffer (drop if full)
                if (MidiInput.messageCount < 256) {
                    var offset = MidiInput.messageCount * 3;
                    MidiInput.messages[offset] = msgType;
                    MidiInput.messages[offset + 1] = note;
                    MidiInput.messages[offset + 2] = velocity;
                    MidiInput.messageCount++;
                }
            },

            // FFI functions called from Rust

            init: function() {
                MidiInput.requestAccess();
            },

            isConnected: function() {
                return MidiInput.input ? 1 : 0;
            },

            getMessageCount: function() {
                return MidiInput.messageCount;
            },

            // Copy messages to WASM memory and clear buffer
            copyMessages: function(destPtr, maxCount) {
                var count = Math.min(MidiInput.messageCount, maxCount);
                if (count > 0) {
                    var dest = new Uint8Array(wasm_memory.buffer, destPtr, count * 3);
                    dest.set(MidiInput.messages.subarray(0, count * 3));
                }
                MidiInput.messageCount = 0;
                return count;
            },

            // Copy device name to WASM memory
            copyDeviceName: function(destPtr, maxLen) {
                var name = MidiInput.deviceName;
                var encoder = new TextEncoder();
                var bytes = encoder.encode(name);
                var len = Math.min(bytes.length, maxLen);
                var mem = new Uint8Array(wasm_memory.buffer, destPtr, len);
                mem.set(bytes.subarray(0, len));
                return len;
            },

            getDeviceCount: function() {
                if (!MidiInput.access) return 0;
                return MidiInput.access.inputs.size;
            },

            connectDevice: function(index) {
                if (!MidiInput.access) return 0;

                var i = 0;
                var found = false;
                MidiInput.access.inputs.forEach(function(input) {
                    if (i === index && !found) {
                        MidiInput.connectInput(input);
                        found = true;
                    }
                    i++;
                });

                return found ? 1 : 0;
            }
        };

        // =============================================================================
        // GCP Authentication (Google Identity Services)
        // =============================================================================

        var GcpAuth = {
            clientId: '93370111666-0ehu6ri1913ht4f7ur6gauiqffq6nvll.apps.googleusercontent.com',
            idToken: null,       // JWT for Cloud Run authentication
            accessToken: null,   // Kept for compatibility (not used for Cloud Run)
            userIdHash: null,
            userEmail: null,     // Email for revoke() on sign-out
            tokenExpiry: 0,
            initialized: false,
            gisLoaded: false,
            hiddenButton: null,  // Reference to hidden sign-in button element

            // Initialize auth - load GIS library and restore token from localStorage
            init: function() {
                if (GcpAuth.initialized) return;
                GcpAuth.initialized = true;

                // Restore token from localStorage if still valid
                var storedIdToken = localStorage.getItem('_b32_gcp_id_token');
                var storedExpiry = parseInt(localStorage.getItem('_b32_gcp_token_expiry') || '0');
                var storedHash = localStorage.getItem('_b32_gcp_user_hash');

                if (storedIdToken && storedExpiry > Date.now() && storedHash) {
                    GcpAuth.idToken = storedIdToken;
                    GcpAuth.accessToken = storedIdToken; // For compatibility
                    GcpAuth.tokenExpiry = storedExpiry;
                    GcpAuth.userIdHash = storedHash;
                    GcpAuth.userEmail = localStorage.getItem('_b32_gcp_user_email');
                    console.log('GCP auth restored from localStorage');
                }

                // Load Google Identity Services library
                var script = document.createElement('script');
                script.src = 'https://accounts.google.com/gsi/client';
                script.async = true;
                script.defer = true;
                script.onload = function() {
                    GcpAuth.gisLoaded = true;
                    console.log('Google Identity Services loaded');

                    // Initialize Google Sign-In with ID token callback
                    google.accounts.id.initialize({
                        client_id: GcpAuth.clientId,
                        callback: GcpAuth.handleCredentialResponse,
                        auto_select: false,
                        cancel_on_tap_outside: true
                    });

                    // Pre-render hidden button for programmatic triggering
                    GcpAuth.setupHiddenButton();
                };
                script.onerror = function() {
                    console.warn('Failed to load Google Identity Services');
                };
                document.head.appendChild(script);
            },

            // Pre-render hidden Google Sign-In button for programmatic triggering
            setupHiddenButton: function() {
                var container = document.createElement('div');
                container.id = '_b32_hidden_signin';
                container.style.cssText = 'position:absolute;top:-9999px;left:-9999px;';
                document.body.appendChild(container);

                google.accounts.id.renderButton(container, {
                    type: 'standard',
                    theme: 'filled_blue',
                    size: 'large',
                    text: 'signin_with',
                    ux_mode: 'popup'  // Opens popup window
                });

                GcpAuth.hiddenButton = container.querySelector('div[role=button]');
                console.log('Hidden sign-in button ready');
            },

            // Handle credential response from Google Sign-In
            handleCredentialResponse: async function(response) {
                if (response.credential) {
                    GcpAuth.idToken = response.credential;
                    GcpAuth.accessToken = response.credential; // For compatibility

                    // Decode JWT to get expiry and user info
                    // JWT format: header.payload.signature (base64url encoded)
                    try {
                        var parts = response.credential.split('.');
                        if (parts.length === 3) {
                            var payload = JSON.parse(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')));

                            // Get expiry from JWT (exp is in seconds)
                            GcpAuth.tokenExpiry = (payload.exp || 0) * 1000;

                            // Hash the user's sub (unique Google ID) for privacy
                            if (payload.sub) {
                                GcpAuth.userIdHash = await GcpAuth.sha256(payload.sub);
                                localStorage.setItem('_b32_gcp_user_hash', GcpAuth.userIdHash);
                            }

                            // Store email for revoke() on sign-out
                            if (payload.email) {
                                GcpAuth.userEmail = payload.email;
                                localStorage.setItem('_b32_gcp_user_email', payload.email);
                            }
                        }
                    } catch (e) {
                        console.error('Failed to decode JWT:', e);
                        // Fallback: assume 1 hour expiry
                        GcpAuth.tokenExpiry = Date.now() + 3600 * 1000;
                    }

                    // Store in localStorage
                    localStorage.setItem('_b32_gcp_id_token', response.credential);
                    localStorage.setItem('_b32_gcp_token_expiry', GcpAuth.tokenExpiry.toString());

                    console.log('GCP sign-in successful (ID token)');
                    console.log('User ID hash computed');
                } else {
                    console.warn('GCP sign-in failed: no credential');
                }
            },

            // Trigger Google sign-in via hidden button -> popup window
            signIn: function() {
                if (!GcpAuth.gisLoaded) {
                    console.warn('Google Identity Services not loaded yet');
                    return;
                }

                if (!GcpAuth.hiddenButton) {
                    console.warn('Sign-in button not ready, attempting setup...');
                    GcpAuth.setupHiddenButton();
                    setTimeout(function() {
                        if (GcpAuth.hiddenButton) {
                            GcpAuth.hiddenButton.click();
                        }
                    }, 100);
                    return;
                }

                // Single click opens Google popup window directly
                GcpAuth.hiddenButton.click();
            },

            // SHA256 hash function
            sha256: async function(message) {
                var msgBuffer = new TextEncoder().encode(message);
                var hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
                var hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(function(b) { return b.toString(16).padStart(2, '0'); }).join('');
            },

            // Sign out
            signOut: function() {
                // Revoke credential with Google to force fresh token on next sign-in
                var emailToRevoke = GcpAuth.userEmail;
                if (GcpAuth.gisLoaded && emailToRevoke) {
                    google.accounts.id.revoke(emailToRevoke, function(done) {
                        console.log('GCP credential revoked:', done.successful ? 'success' : 'failed');
                    });
                }

                // Also disable auto-select
                if (GcpAuth.gisLoaded) {
                    google.accounts.id.disableAutoSelect();
                }

                // Clear local state
                GcpAuth.idToken = null;
                GcpAuth.accessToken = null;
                GcpAuth.userIdHash = null;
                GcpAuth.userEmail = null;
                GcpAuth.tokenExpiry = 0;
                localStorage.removeItem('_b32_gcp_id_token');
                localStorage.removeItem('_b32_gcp_token');
                localStorage.removeItem('_b32_gcp_token_expiry');
                localStorage.removeItem('_b32_gcp_user_hash');
                localStorage.removeItem('_b32_gcp_user_email');

                console.log('GCP signed out');
            },

            // Check if authenticated (ID token exists and not expired)
            isAuthenticated: function() {
                var hasToken = !!GcpAuth.idToken;
                var notExpired = GcpAuth.tokenExpiry > Date.now();
                var hasHash = !!GcpAuth.userIdHash;
                var authenticated = hasToken && notExpired && hasHash;

                // Debug: log auth check details on failure
                if (hasToken && !authenticated) {
                    console.log('[GcpAuth] Auth check failed:',
                        'token=' + (hasToken ? 'yes' : 'no'),
                        'expiry=' + new Date(GcpAuth.tokenExpiry).toISOString(),
                        'now=' + new Date().toISOString(),
                        'expired=' + !notExpired,
                        'hash=' + (hasHash ? 'yes' : 'no'));
                }

                return authenticated ? 1 : 0;
            },

            // Get access token length (returns ID token for Cloud Run auth)
            getAccessTokenLen: function() {
                return GcpAuth.idToken ? GcpAuth.idToken.length : 0;
            },

            // Copy access token to WASM memory (returns ID token for Cloud Run auth)
            copyAccessToken: function(destPtr, maxLen) {
                if (!GcpAuth.idToken) return 0;
                return writeWasmBytes(destPtr, new TextEncoder().encode(GcpAuth.idToken), maxLen);
            },

            // Get user ID hash length
            getUserIdHashLen: function() {
                return GcpAuth.userIdHash ? GcpAuth.userIdHash.length : 0;
            },

            // Copy user ID hash to WASM memory
            copyUserIdHash: function(destPtr, maxLen) {
                if (!GcpAuth.userIdHash) return 0;
                return writeWasmBytes(destPtr, new TextEncoder().encode(GcpAuth.userIdHash), maxLen);
            }
        };

        // =============================================================================
        // GCP Cloud Storage (via Cloud Run API)
        // =============================================================================

        var GcpStorage = {
            baseUrl: 'https://bonnie32-storage-api-4bcenv646q-uc.a.run.app',

            // Pending operations (fire-and-poll pattern)
            // Each operation has: { id, status: 'pending'|'ready'|'error', result, error }
            operations: {},
            nextOpId: 1,

            // Start a list operation, returns operation ID
            startList: function(pathPtr, pathLen) {
                var path = readWasmString(pathPtr, pathLen);
                var opId = GcpStorage.nextOpId++;

                GcpStorage.operations[opId] = { status: 'pending', result: null, error: null };
                console.log('[GcpStorage] List started, opId=' + opId + ', path=' + path);

                GcpStorage.doRequest('GET', '/list?prefix=' + encodeURIComponent(path))
                    .then(function(data) {
                        // Server returns: {"success": true, "data": {"files": [{"path": "...", "size": N}]}}
                        var files = (data.data && data.data.files) || [];
                        console.log('[GcpStorage] List success, opId=' + opId + ', files=', files);
                        if (GcpStorage.operations[opId]) {
                            GcpStorage.operations[opId].status = 'ready';
                            GcpStorage.operations[opId].result = files.map(function(f) { return f.path; });
                        }
                    })
                    .catch(function(err) {
                        console.error('[GcpStorage] List error, opId=' + opId + ':', err);
                        if (GcpStorage.operations[opId]) {
                            GcpStorage.operations[opId].status = 'error';
                            GcpStorage.operations[opId].error = err.message;
                        }
                    });

                return opId;
            },

            // Start a read operation, returns operation ID
            startRead: function(pathPtr, pathLen) {
                var path = readWasmString(pathPtr, pathLen);
                var opId = GcpStorage.nextOpId++;

                GcpStorage.operations[opId] = { status: 'pending', result: null, error: null };

                GcpStorage.doRequest('GET', '/get?path=' + encodeURIComponent(path))
                    .then(function(data) {
                        // data.data.content is base64 encoded (wrapped in ApiResponse)
                        var binary = atob(data.data.content);
                        var bytes = new Uint8Array(binary.length);
                        for (var i = 0; i < binary.length; i++) {
                            bytes[i] = binary.charCodeAt(i);
                        }
                        if (GcpStorage.operations[opId]) {
                            GcpStorage.operations[opId].status = 'ready';
                            GcpStorage.operations[opId].result = bytes;
                        }
                    })
                    .catch(function(err) {
                        if (GcpStorage.operations[opId]) {
                            GcpStorage.operations[opId].status = 'error';
                            GcpStorage.operations[opId].error = err.message;
                        }
                    });

                return opId;
            },

            // Start a write operation, returns operation ID
            startWrite: function(pathPtr, pathLen, dataPtr, dataLen) {
                var path = readWasmString(pathPtr, pathLen);
                var data = new Uint8Array(wasm_exports.memory.buffer, dataPtr, dataLen);

                // Convert to base64
                var binary = '';
                for (var i = 0; i < data.length; i++) {
                    binary += String.fromCharCode(data[i]);
                }
                var base64 = btoa(binary);

                var opId = GcpStorage.nextOpId++;
                GcpStorage.operations[opId] = { status: 'pending', result: null, error: null };
                console.log('[GcpStorage] Write started, opId=' + opId + ', path=' + path + ', size=' + data.length);

                GcpStorage.doRequest('POST', '/upload', { path: path, content: base64 })
                    .then(function() {
                        console.log('[GcpStorage] Write success, opId=' + opId);
                        if (GcpStorage.operations[opId]) {
                            GcpStorage.operations[opId].status = 'ready';
                            GcpStorage.operations[opId].result = true;
                        }
                    })
                    .catch(function(err) {
                        console.error('[GcpStorage] Write error, opId=' + opId + ':', err);
                        if (GcpStorage.operations[opId]) {
                            GcpStorage.operations[opId].status = 'error';
                            GcpStorage.operations[opId].error = err.message;
                        }
                    });

                return opId;
            },

            // Start a delete operation, returns operation ID
            startDelete: function(pathPtr, pathLen) {
                var path = readWasmString(pathPtr, pathLen);
                var opId = GcpStorage.nextOpId++;

                GcpStorage.operations[opId] = { status: 'pending', result: null, error: null };

                GcpStorage.doRequest('POST', '/delete', { path: path })
                    .then(function() {
                        if (GcpStorage.operations[opId]) {
                            GcpStorage.operations[opId].status = 'ready';
                            GcpStorage.operations[opId].result = true;
                        }
                    })
                    .catch(function(err) {
                        if (GcpStorage.operations[opId]) {
                            GcpStorage.operations[opId].status = 'error';
                            GcpStorage.operations[opId].error = err.message;
                        }
                    });

                return opId;
            },

            // Poll operation status: 0=pending, 1=ready, 2=error
            pollStatus: function(opId) {
                var op = GcpStorage.operations[opId];
                if (!op) {
                    console.warn('[GcpStorage] pollStatus: operation not found, opId=' + opId);
                    return 2; // Error: operation not found
                }
                // Log status changes
                if (!op._lastLoggedStatus || op._lastLoggedStatus !== op.status) {
                    console.log('[GcpStorage] pollStatus opId=' + opId + ' status=' + op.status);
                    op._lastLoggedStatus = op.status;
                }
                if (op.status === 'pending') return 0;
                if (op.status === 'ready') return 1;
                return 2; // Error
            },

            // Get result data length (for read operations)
            getResultLen: function(opId) {
                var op = GcpStorage.operations[opId];
                if (!op || !op.result) return 0;
                if (op.result instanceof Uint8Array) return op.result.length;
                if (Array.isArray(op.result)) {
                    // For list operations, join filenames with newlines
                    return op.result.join('\n').length;
                }
                return 0;
            },

            // Copy result data to WASM memory
            copyResult: function(opId, destPtr, maxLen) {
                var op = GcpStorage.operations[opId];
                if (!op || !op.result) return 0;

                var data;
                if (op.result instanceof Uint8Array) {
                    data = op.result;
                } else if (Array.isArray(op.result)) {
                    data = new TextEncoder().encode(op.result.join('\n'));
                } else {
                    return 0;
                }

                return writeWasmBytes(destPtr, data, maxLen);
            },

            // Get error message length
            getErrorLen: function(opId) {
                var op = GcpStorage.operations[opId];
                return op && op.error ? op.error.length : 0;
            },

            // Copy error message to WASM memory
            copyError: function(opId, destPtr, maxLen) {
                var op = GcpStorage.operations[opId];
                if (!op || !op.error) return 0;
                return writeWasmBytes(destPtr, new TextEncoder().encode(op.error), maxLen);
            },

            // Free operation (remove from memory)
            freeOperation: function(opId) {
                delete GcpStorage.operations[opId];
            },

            // Yield counter for logging
            _yieldCount: 0,

            // Yield to event loop (allows pending fetch callbacks to run)
            // Uses sync XHR trick - blocks WASM but lets JS process events
            yield: function() {
                GcpStorage._yieldCount++;
                if (GcpStorage._yieldCount % 10 === 0) {
                    console.log('[GcpStorage] yield called ' + GcpStorage._yieldCount + ' times, pending ops:',
                        Object.keys(GcpStorage.operations).filter(function(k) {
                            return GcpStorage.operations[k].status === 'pending';
                        }).join(','));
                }
                try {
                    var xhr = new XMLHttpRequest();
                    xhr.open('GET', 'data:text/plain,', false); // synchronous
                    xhr.send();
                } catch (e) {
                    console.log('[GcpStorage] yield XHR error (ignored):', e);
                }
            },

            // Get quota info, returns operation ID
            startGetQuota: function() {
                var opId = GcpStorage.nextOpId++;
                GcpStorage.operations[opId] = { status: 'pending', result: null, error: null };

                GcpStorage.doRequest('GET', '/quota')
                    .then(function(data) {
                        GcpStorage.operations[opId].status = 'ready';
                        // Store as JSON string for simplicity
                        GcpStorage.operations[opId].result = new TextEncoder().encode(JSON.stringify(data));
                    })
                    .catch(function(err) {
                        GcpStorage.operations[opId].status = 'error';
                        GcpStorage.operations[opId].error = err.message;
                    });

                return opId;
            },

            // Internal: make authenticated request to Cloud Run
            doRequest: async function(method, endpoint, body) {
                if (!GcpAuth.isAuthenticated()) {
                    throw new Error('Not authenticated');
                }

                // Extra safety: check token expiry with 60-second buffer
                // This catches cases where isAuthenticated passed but token is about to expire
                if (GcpAuth.tokenExpiry && GcpAuth.tokenExpiry < Date.now() + 60000) {
                    console.warn('[GcpStorage] Token expires in <60s, signing out');
                    GcpAuth.signOut();
                    throw new Error('Token expired, please sign in again');
                }

                var url = GcpStorage.baseUrl + endpoint;
                var options = {
                    method: method,
                    cache: 'no-store',  // Prevent browser caching of API responses
                    headers: {
                        'Authorization': 'Bearer ' + GcpAuth.idToken,
                        'Content-Type': 'application/json'
                    }
                };

                if (body) {
                    options.body = JSON.stringify(body);
                }

                var response = await fetch(url, options);

                if (!response.ok) {
                    var errorText = await response.text();

                    // Only sign out if it's a CLIENT auth issue (401 from server directly)
                    // NOT if it's a server-side Firestore/GCS auth issue (400 with nested error)
                    if (response.status === 401) {
                        console.warn('[GcpStorage] Client auth rejected (401), signing out');
                        GcpAuth.signOut();
                    } else if (response.status === 400 && errorText.includes('Firestore')) {
                        // Server-side Firestore auth issue - don't sign out the user
                        console.error('[GcpStorage] Server-side Firestore error - this is a backend issue, not client auth');
                    }

                    throw new Error(response.status + ': ' + errorText);
                }

                // Handle empty responses (e.g., delete)
                var text = await response.text();
                return text ? JSON.parse(text) : {};
            }
        };

        // =============================================================================
        // Register WASM imports
        // =============================================================================

        miniquad_add_plugin({
            register_plugin: function(importObject) {
                var env = importObject.env;

                // Gamepad input
                env.b32_gamepad_has_gamepad = GamepadInput.hasGamepad;
                env.b32_gamepad_get_button_mask = GamepadInput.getButtonMask;
                env.b32_gamepad_get_button_pressed_mask = GamepadInput.getButtonPressedMask;
                env.b32_gamepad_get_left_stick_x = GamepadInput.getLeftStickX;
                env.b32_gamepad_get_left_stick_y = GamepadInput.getLeftStickY;
                env.b32_gamepad_get_right_stick_x = GamepadInput.getRightStickX;
                env.b32_gamepad_get_right_stick_y = GamepadInput.getRightStickY;
                env.b32_gamepad_get_left_trigger = GamepadInput.getLeftTrigger;
                env.b32_gamepad_get_right_trigger = GamepadInput.getRightTrigger;
                env.b32_gamepad_copy_name = GamepadInput.copyName;

                // MIDI input
                env.b32_midi_init = MidiInput.init;
                env.b32_midi_is_connected = MidiInput.isConnected;
                env.b32_midi_get_message_count = MidiInput.getMessageCount;
                env.b32_midi_copy_messages = MidiInput.copyMessages;
                env.b32_midi_copy_device_name = MidiInput.copyDeviceName;
                env.b32_midi_get_device_count = MidiInput.getDeviceCount;
                env.b32_midi_connect_device = MidiInput.connectDevice;

                // File I/O
                env.b32_import_file = FileIO.import;
                env.b32_check_import = FileIO.checkImport;
                env.b32_get_import_data_len = FileIO.getImportDataLen;
                env.b32_get_import_filename_len = FileIO.getImportFilenameLen;
                env.b32_copy_import_data = FileIO.copyImportData;
                env.b32_copy_import_filename = FileIO.copyImportFilename;
                env.b32_clear_import = FileIO.clearImport;
                env.b32_set_export_data = FileIO.setExportData;
                env.b32_set_export_filename = FileIO.setExportFilename;
                env.b32_trigger_download = FileIO.triggerDownload;

                // Loading UI
                env.b32_set_loading_progress = LoadingUI.setProgress;
                env.b32_set_loading_status = LoadingUI.setStatus;
                env.b32_hide_loading = LoadingUI.hide;

                // Texture cache
                env.b32_is_prefetch_complete = TextureCache.isComplete;
                env.b32_get_cached_texture_info = TextureCache.getInfo;
                env.b32_copy_cached_texture = TextureCache.copyData;

                // Soundfont cache
                env.b32_is_soundfont_loaded = SoundfontCache.isLoaded;
                env.b32_get_soundfont_size = SoundfontCache.getSize;
                env.b32_copy_soundfont = SoundfontCache.copyData;

                // Audio output
                env.b32_audio_init = AudioOutput.init;
                env.b32_audio_write = AudioOutput.write;

                // URL opening - only allow http/https protocols for security
                env.b32_open_url = function(ptr, len) {
                    var url = readWasmString(ptr, len);
                    if (url.startsWith('http://') || url.startsWith('https://')) {
                        window.open(url, '_blank');
                    } else {
                        console.warn('Blocked non-HTTP URL:', url);
                    }
                };

                // GCP Authentication
                env.b32_gcp_auth_init = GcpAuth.init;
                env.b32_gcp_auth_sign_in = GcpAuth.signIn;
                env.b32_gcp_auth_sign_out = GcpAuth.signOut;
                env.b32_gcp_auth_is_authenticated = GcpAuth.isAuthenticated;
                env.b32_gcp_auth_get_token_len = GcpAuth.getAccessTokenLen;
                env.b32_gcp_auth_copy_token = GcpAuth.copyAccessToken;
                env.b32_gcp_auth_get_user_hash_len = GcpAuth.getUserIdHashLen;
                env.b32_gcp_auth_copy_user_hash = GcpAuth.copyUserIdHash;

                // GCP Storage
                env.b32_gcp_storage_list = GcpStorage.startList;
                env.b32_gcp_storage_read = GcpStorage.startRead;
                env.b32_gcp_storage_write = GcpStorage.startWrite;
                env.b32_gcp_storage_delete = GcpStorage.startDelete;
                env.b32_gcp_storage_poll = GcpStorage.pollStatus;
                env.b32_gcp_storage_get_result_len = GcpStorage.getResultLen;
                env.b32_gcp_storage_copy_result = GcpStorage.copyResult;
                env.b32_gcp_storage_get_error_len = GcpStorage.getErrorLen;
                env.b32_gcp_storage_copy_error = GcpStorage.copyError;
                env.b32_gcp_storage_free = GcpStorage.freeOperation;
                env.b32_gcp_storage_get_quota = GcpStorage.startGetQuota;
                env.b32_gcp_storage_yield = GcpStorage.yield;
            }
        });

        // =============================================================================
        // Startup
        // =============================================================================

        // Prefetch textures and soundfont in parallel, then start WASM
        Promise.all([
            TextureCache.prefetchAll(),
            SoundfontCache.prefetch()
        ]).then(function() {
            // Add version for cache-busting
            load('bonnie-32.wasm?v=0.1.10');
        });

    })();
    </script>
</body>
</html>
